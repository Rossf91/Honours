//                      Confidential Information
//           Limited Distribution to Authorized Persons Only
//         Copyright (C) 2003-2005 The University of Edinburgh
//                        All Rights Reserved
//
// =====================================================================
//
// Description:
//
//  This file defines the classes used to represent the esystem.
//  The 'system' is an SoC device containing a 'processor', 'memories'
//  and possibly I/O devices.
//
// =====================================================================

#ifndef _system_h_
#define _system_h_

#include "sim_types.h"

#include "arch/Configuration.h"
#include "sys/mem/Memory.h"
#include "uarch/memory/MemoryModel.h"

#include "translate/TranslationManager.h"

#include "mem/mmap/IODeviceManager.h"

#include <fcntl.h>
#include <unistd.h>
#include <string>
#include <ELFIO.h>

// ----------------------------------------------------------------------------
// FORWARD DECLARATIONS
//

namespace arcsim {
  namespace util {
    class SymbolTable;
  }
  
  namespace mem {
    class MemoryDeviceInterface;
  }
  
  namespace ioc {
    class Context;
  }
  
  namespace internal {
    namespace system {
        class Processor;
    }
  }
}

struct UpdatePacket;

// ----------------------------------------------------------------------------
// CLASSES
//

class System
{
public:
  // Unique autogenerated system id
  //
  const uint32          id;
  
  arcsim::ioc::Context&  sys_ctx;
  
  // System Configuration and short cut references to SimOptions
  //
  Configuration&  sys_conf;           // System Configuration class
  SimOptions&     sim_opts;           // SimOptions class
  
  // Modules in this System
  //
  uint32                         total_modules;
  
  // Processors in this System
  //
  uint32                         total_cores;        // Total No. cores
  arcsim::sys::cpu::Processor*   cpu[MAX_NO_CORES];  // Core objects

  // Memory and MemoryModel
  //
  arcsim::sys::mem::Memory* ext_mem;            // Main memory
  MainMemoryModel*          ext_mem_c;          // Main memory cycle accurate model

  // Shadow memory
  //
  arcsim::sys::mem::Memory* dmem;               // shadow memory for hardware data memory
  
  
  // JIT TranslationManager responsible for JIT compilation
  //
  arcsim::internal::translate::TranslationManager trans_mgr;
  
  // Device manager for builtin memory mapped devices
  //
  arcsim::mem::mmap::IODeviceManager               io_iom_device_manager;

  // Constructor
  //
  System  (Configuration& a);
  
  // Destructor
  //
  ~System ();
  
  // Create/Destroy system
  //
  void create_system ();
  void destroy_system ();
  
  // Reset system to its initial state
  //
  void reset_to_initial_state(bool purge_translations);
  
  // Start simulation
  //
  bool start_simulation(int argc, char *argv[]);
  void setup_simulated_stack (int argc, int first_arg, const char *arg0, char* const argv[]);
    
  void hard_reset ();
  void soft_reset ();
  void halt_cpu ();
  // Load various binary formats
  //
  int  load_elf32 (const char *objfile);
  int  load_quicksim_hex (const char *objfile);
  int  load_binary_image (const char *imgfile);
  
  bool    get_symbol(uint32 addr, std::string& name);
  uint32  get_entry_point();
  
  bool simulate ();
  bool interact ();
  bool run ();
  bool run_notrace ();
  bool run_trace ();
  
  bool step ();
  bool step (UpdatePacket*);
  bool trace(UpdatePacket*);
  
  bool set_breakpoint   (uint32 brk_loc, bool& brk_s, uint32& old_instr);
  bool clear_breakpoint (uint32 brk_loc, uint32 old_instr, bool brk_s);
  
  void print_stats ();
  void dump_state  ();
  

  void emulate_syscall(arcsim::sys::cpu::Processor& cpu,
                       int call,  uint32& res,
                       uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5);

  uint64 clock_ticks();

  
  // --------------------------------------------------------------------------
  // Memory related functions
  //
  
  // Read and write to physical system memory bypassing memory devices
  //
  inline bool writeWord (uint32 addr, uint32  data)
  {
    return ext_mem->write32( addr, data );
  }
  inline bool readWord (uint32 addr, uint32& data)
  {
    return ext_mem->read32( addr, data );
  }    
  inline arcsim::sys::mem::BlockData* get_host_page (uint32 addr)
  {
    return ext_mem->get_host_page (addr);
  }

  inline uint32* get_host_page_location (uint32 addr)
  {
    return ext_mem->get_host_page_ptr (addr);
  }

  // Write to memory AND memory devices if registered for the respective address
  //
  bool write_to_memory (uint32 addr, uint32 data, int size);
  
  // --------------------------------------------------------------------------
  // Shadow memory related functions
  //
  
  // Read and write to hardware shadow memory
  //
  bool writeShadow32(uint32 addr, uint32 data);
  bool writeShadow16(uint32 addr, uint32 data);
  bool writeShadow8 (uint32 addr, uint32 data);
  bool readShadow32 (uint32 addr, uint32& data);
  bool readShadow16 (uint32 addr, uint32& data);
  bool readShadow8  (uint32 addr, uint32& data);

  // Read from physical system memory bypassing memory devices
  //
  void dmem_block_write (char *buf, uint32 addr, int size);
  
private:
  arcsim::util::SymbolTable&  sym_tab_;
  
  uint32                      heap_base_;
  uint32                      heap_limit_;
  uint32                      stack_top_;
  uint32                      entry_point_;
  
  void*                       io_plugin_handle;
  void*                       ise_plugin_handle;

};

#endif
